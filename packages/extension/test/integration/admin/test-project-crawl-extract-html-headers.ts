import queryString from 'query-string';
import { assert } from 'chai';
import { readFileSync } from 'fs';
import { join, resolve } from 'path';
import BrowserHelper from '../../utils/BrowserHelper';
import TestUtils from 'get-set-fetch/test/utils/TestUtils';

/* eslint-disable no-shadow */
describe('Project Crawl Extract HTML Headers', () => {
  let browser = null;
  let adminPage = null;

  const targetDir = join('test', 'tmp'); // ../../test/tmp';

  const gotoOpts = {
    timeout: 10 * 1000,
    waitUntil: 'load'
  };

  const queryParams = queryString.stringify({ redirectPath: '/projects' });

  const actualProject = {
    name: 'projectA',
    description: 'projectA description',
    url: 'http://www.sitea.com/index.html',
    opts: {},
    // directly set scenarioId and overwrite pluginDefinitions normally generated by a scenario instance
    scenarioId: 1,
    pluginDefinitions: [
      {
        name: 'SelectResourcePlugin'
      },
      {
        name: 'ExtensionFetchPlugin'
      },
      {
        name: 'ExtractUrlPlugin'
      },
      {
        name: 'ExtractTitlePlugin'
      },
      {
        name: 'UpdateResourcePlugin'
      },
      {
        name: 'InsertResourcePlugin'
      }
    ]
  };

  before(async () => {
    browser = await BrowserHelper.launch();
    adminPage = await browser.newPage();
    await BrowserHelper.waitForDBInitialization(adminPage);
  });

  afterEach(async () => {
    // cleanup fs
    TestUtils.emptyDir(targetDir);

    // move to admin page
    await adminPage.goto(`chrome-extension://${extension.id}/admin/admin.html?${queryParams}`, gotoOpts);

    // delete existing projects
    const existingProjects = await adminPage.evaluate(() => GsfClient.fetch('GET', 'projects'));
    if (!existingProjects) return;
    const projectIds = existingProjects.map(existingProject => existingProject.id);
    await adminPage.evaluate(projectIds => GsfClient.fetch('DELETE', 'projects', { ids: projectIds }), projectIds);
  });

  after(async () => {
    await browser.close();
  });

  async function waitForCrawlComplete(adminPage, siteId, resolve = null) {
    // if no promise defined return one
    if (!resolve) {
      return new Promise((resolve) => {
        setTimeout(waitForCrawlComplete, 5000, adminPage, siteId, resolve);
      });
    }

    const notCrawledResources = await adminPage.evaluate(siteId => GsfClient.fetch('GET', `resources/${siteId}/notcrawled`), siteId);

    // crawl complete, there are no more resources to be crawled
    if (notCrawledResources.length === 0) {
      resolve();
    }
    else {
      setTimeout(waitForCrawlComplete, 5000, adminPage, siteId, resolve);
    }

    return null;
  }

  it('Test Crawl Project Html Headers', async () => {
    // open project list
    await adminPage.goto(`chrome-extension://${extension.id}/admin/admin.html?${queryParams}`, gotoOpts);

    // create project to crawl
    await adminPage.evaluate(project => GsfClient.fetch('POST', 'project', project), actualProject);
    const projects = await adminPage.evaluate(() => GsfClient.fetch('GET', 'projects'));
    assert.strictEqual(1, projects.length);
    const loadedProject = projects[0];
    const loadedSites = await adminPage.evaluate(projectId => GsfClient.fetch('GET', `sites/${projectId}`), loadedProject.id);
    assert.strictEqual(1, loadedSites.length);
    const loadedSite = loadedSites[0];

    // reload project list
    await adminPage.goto(`chrome-extension://${extension.id}/admin/admin.html?${queryParams}`, gotoOpts);
    const crawlInputId = `input#crawl-${loadedProject.id}[type=button]`;
    await adminPage.waitFor(crawlInputId);

    // start crawling project
    await adminPage.click(crawlInputId);

    // wait for all resources to be crawled (resource.crawledAt is updated for all resources)
    await waitForCrawlComplete(adminPage, loadedSite.id);

    // retrieve crawled resources
    const crawledResources = await adminPage.evaluate(siteId => GsfClient.fetch('GET', `resources/${siteId}/crawled`), loadedSite.id);
    assert.strictEqual(3, crawledResources.length);

    // check each resource
    const titles = {
      'http://www.sitea.com/index.html': 'siteA',
      'http://www.sitea.com/pageA.html': 'pageA',
      'http://www.sitea.com/pageB.html': 'pageB'
    };
    for (let i = 0; i < crawledResources.length; i += 1) {
      const crawledResource = crawledResources[i];
      assert.strictEqual('text/html', crawledResource.mediaType);
      assert.strictEqual(titles[crawledResource.url], crawledResource.info.title);
    }

    // reload project list
    await adminPage.goto(`chrome-extension://${extension.id}/admin/admin.html?${queryParams}`, gotoOpts);
    adminPage.bringToFront();

    // goto project results page
    const resultsInputId = `input#results-${loadedProject.id}[type=button]`;
    await adminPage.click(resultsInputId);

    // start a CDPSession in order to change download behavior via Chrome Devtools Protocol
    const client = await adminPage
      .target()
      .createCDPSession();
    await client.send('Page.setDownloadBehavior', {
      behavior: 'allow',
      downloadPath: resolve(targetDir)
    });

    // download csv
    const exportCsvId = `a#csv-${loadedProject.id}`;
    await adminPage.waitFor(exportCsvId);
    await adminPage.click(exportCsvId);

    // wait a bit for file to be generated and saved
    await new Promise(resolve => setTimeout(resolve, 1000));

    // check file content
    const expectedHeader = 'title';
    const expectedBody = Object
      .values(titles)
      .join('\n');
    const expectedCsv = `${expectedHeader}\n${expectedBody}`;
    const generatedCsv = readFileSync(resolve('./', 'test', 'tmp', `${loadedProject.name}.txt`), 'utf8');
    assert.strictEqual(expectedCsv, generatedCsv);
  });
});
